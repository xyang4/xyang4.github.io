

[TOC]



# 前言

## 编写目的

>  梳理 Java 语言基础及项目实战中常用的技术点，备战面试，做到吊打面试官😄。



**智联`某互联网公司`高级Java开发`招聘需求：**

- 深入理解 JAVA 集合，多线程编程等相关基础知识和 JVM 原理；                          ==java基础、多线程、JVM==
- 熟练使用 SQL 语句及优化，对数据库事务、锁、索引有深入理解；                    ==数据库优化==
- 熟悉 Spring Boot、Spring Cloud 及微服务周边中间件，有实践经验；		      ==微服务相关==
- 熟悉常见数据结构和算法及设计模式，有分布式系统设计经验；			              ==数据结构、设计模式及算法==
- 深入理解常用的缓存中间件如 redis，memcache，具备分布式缓存设计经验；==缓存及使用经验==
- 具备良好的编码规范和软件工程思维；	           ==编码习惯、OOP及解决问题的思维、方式方法==
- 有 Hadoop 大数据开发经验者优先                 	==大数据相关：Spark、Hadoop（最好是能说明白 Yarn 调度原理）==
- 具备独立分析和解决问题能力，积极主动、认真踏实，有良好的协调沟通能力。     

---



# 第一章 Core Java

## 1. Java 基础及集合

### 1.1 String 为什么是 Final 的

> 从`高率、安全`角度说明

### 1.2 面向对象的特性

#### 封装

#### 继承

#### 多态

- 静态多态
- 动态多态

### 1.3 接口与抽象类的区别

### 1.4 反射的用途及实现

### 1.5 JDK 源码

#### HashMap 实现原理

- 初始容量是2的指数幂
- 加载因子0.75
- 扩容死锁机环链形行程分析 
- 链表转红黑树过程

#### HashSet 实现原理

#### ArrayList 实现原理

#### ConcurrentHashMap 实现原理

### 1.6 Java spi 动态服务扩展机制

> Service Provider Interface，应用于厂商自定义组件或插件中，为某个接口寻找服务实现的机制。

### 1.7 类载机制

- **类加载器**

|           加载器类型            | 职责                                                         | 注意事项                                                     |
| :-----------------------------: | :----------------------------------------------------------- | ------------------------------------------------------------ |
|    启动（Bootstrap）类加载器    | 负责将 Java_Home/lib 下面的类库加载到内存中（比如 **rt.jar**）。 | 由于引导类加载器涉及到虚拟机本地实现细节，开发者无法直接获取到启动类加载器的引用，所以不允许直接通过引用进行操作。 |
|  标准扩展（Extension）类加载器  | 它负责将 Java_Home /lib/ext 或者由系统变量 java.ext.dir 指定位置中的类库加载到内存中。 | 开发者可以直接使用标准扩展类加载器。                         |
| 应用程序（Application）类加载器 | 它负责将系统类路径（CLASSPATH）中指定的类库加载到内存中。    | 开发者可以直接使用系统类加载器。由于这个类加载器是 ClassLoader 中的 `getSystemClassLoader()` 方法的返回值，因此一般称为==系统（System）加载器==。 |



#### 双亲委派模型

> 除了顶层的启动类加载器外，其余的类加载器都应该有自己的父类加载器，而这种父子关系一般通过组合（Composition）关系来实现，而不是通过继承（Inheritance）.

- **委派过程**

​		某个特定的类加载器在接到加载类的请求时，首先将加载任务委托给父类加载器，依次递归，如果父类加载器可以完成类加载任务，就成功返回；只有父类加载器无法完成此加载任务时，才自己去加载。

- **系统实现**

​		在 `java.lang.ClassLoader` 的 `loadClass()` 方法中，先检查是否已经被加载过，若没有加载则调用父类加载器的 `loadClass()` 方法，若父加载器为空则默认使用启动类加载器作为父加载器。如果父加载失败，则抛出 `ClassNotFoundException` 异常后，再调用自己的 `findClass()` 方法进行加载。

- [线程上下文类加载器](https://blog.csdn.net/atongmu2017/article/details/93649837)
- 深拷贝与浅拷贝的区别？

| 拷贝类型 | 共同点                                                       | 特点                 |
| -------- | ------------------------------------------------------------ | -------------------- |
| 浅拷贝   | 复制基本类型的属性；引用类型的属性复制，复制栈中的变量 和 变量指向堆内存中的对象的指针 | 不复制堆内存中的对象 |
| 深拷贝   | 复制基本类型的属性；引用类型的属性复制，复制栈中的变量 和 变量指向堆内存中的对象的指针 | 复制堆内存中的对象   |

- BIO、NIO、AIO 有什么区别？

| 类型 |      |      |
| ---- | ---- | ---- |
| BIO  |      |      |
| NIO  |      |      |
| AIO  |      |      |



- [内存泄漏与内存溢出的区别](https://www.cnblogs.com/rgever/p/8899758.html)

## 2. Web相关

### 2.1 TCP三次握手四次挥手

### 2.2 Session 分布式处理

### 2.3 Servlet

### 2.4 JDBC 流程

### 2.5 MVC 设计思想

### 2.6 同步和异步，阻塞和非阻塞。

### 2.7 OSI 七层模型

### 2.8 Tomcat容器

#### 架构

#### 运行原理

#### 性能调优

## 3. 数据结构及算法

### 3.1 算法

### 3.2 数据结构

| 索引类型                                                     | 特点                                                         | 优点     | 存在不足     | 适用场景                                               |
| ------------------------------------------------------------ | ------------------------------------------------------------ | -------- | ------------ | ------------------------------------------------------ |
| B Tree（二叉搜索树）                                         | 叶子节点指针为空、所有索引元素不重复，具有相同的深度；节点中的数据索引从左到右递增排序 |          |              |                                                        |
| [B+Tree](https://blog.csdn.net/sinat_23619409/article/details/80309652) | 非叶子节点不存储data，只存储index（冗余）,可以存储更多的索引;叶子节点用指针连接（提高区间访问性能），包含所有的索引字段 |          | 支持范围查找 | **排序和检索的效率较高**：大多数数据库、文件系统的存储 |
| 平衡二叉树                                                   |                                                              | 快速查找 |              |                                                        |
| 红黑树                                                       |                                                              |          |              | 多用在内部排序                                         |



## 4. JVM 相关

### 垃圾回收

### Jvm 调优

## 5. 异常体系

### 5.1 JDK 异常体系

Throwable

	- Exception	IOException | RuntimeException
	- Error:  OutOfMemoryError | StackOverFlowError

### 5.2 业务如何定义异常

---

# 第二章 框架

## 1 Spring

### Spring mvc

### Bean 的生命周期

### Spring Ioc

## 2 Mybatis

### 实现原理及其运行流程

### [用到的设计模式](https://mp.weixin.qq.com/s/cXXFJJkgZe_fB_SLkf8rkg)

- **Builder 模式**：SqlSessionFactoryBuilder、XMLConfigBuilder、XMLMapperBuilder、XMLStatementBuilder、CacheBuilder
- **工厂模式** ：SqlSessionFactory、ObjectFactory、MapperProxyFactory等
- **单例模式**：ErrorContext和LogFactory；
- **代理模式**：Mybatis实现的核心，比如MapperProxy、ConnectionLogger，用的jdk的动态代理；还有executor.loader包使用了cglib或者javassist达到延迟加载的效果；
- **适配器模式**：例如Log的Mybatis接口和它对jdbc、log4j等各种日志框架的适配实现；

## 3 全文检索

### 3.1 基本原理

- 倒排索引

### 3.2 组件

- Lucene
- ES

## 4 Dubbo

### 原理及概念

#### 节点角色

- Provider：服务的提供方
- Consumer：调用远程服务的服务消费方
- Registry：服务注册和发现的注册中心
- Monitor：统计服务调用次数和调用时间的监控中心
- Container：服务运行容器

#### 调用关系

1. 服务容器负责启动，加载，运行服务提供者。
2. 服务提供者在启动时，向注册中心注册自己提供的服务。
3. 服务消费者在启动时，向注册中心订阅自己所需的服务。
4. 注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。
5. 服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。
6. 服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心

# 第三章 数据库

## 1 Mysql

### 运行原理

### 存储引擎

| 类型   | 特点 | 不足 |
| ------ | ---- | ---- |
| InnoDb |      |      |
| MyIsam |      |      |



### 锁

| 锁类型 | 特点 | 不足 |
| ------ | ---- | ---- |
| 行锁   |      |      |
| 表锁   |      |      |
| 乐观锁 |      |      |
| 悲观锁 |      |      |

### 数据库事务的集中粒度

### 常见问题

### [sql 优化方案]([https://funtl.com/zh/interview/Java-%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8-MySQL-%E4%BC%98%E5%8C%96.html#%E7%A5%9E%E5%99%A8-explain-%E8%AF%AD%E5%8F%A5](https://funtl.com/zh/interview/Java-面试宝典-MySQL-优化.html#神器-explain-语句))

### 聚簇索引与非聚簇索引的区别

## 2 Nosql

### 2.1 [Redis](https://blog.csdn.net/Butterfly_resting/article/details/89668661)

#### 内部结构及其实现原理

#### 为什么是单线程的

> **官方解释：**因为Redis是基于内存的操作，CPU不是Redis的瓶颈，Redis的瓶颈最有可能是机器内存的大小或者网络带宽。既然单线程容易实现，而且CPU不会成为瓶颈，那就顺理成章地采用单线程的方案了

#### 过期策略

> 即redis针对过期的key使用的清除策略，策略为，定期删除+惰性删除。

| 类型     | 特点                                                         | 不足                                                         |
| -------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 定期删除 | redis默认每隔100ms随机抽取检查：是否有过期的key,有过期key则删除 | 随机抽取检查，所以会导致很多key到时间没有删除                |
| 惰性删除 | 获取指定 key 时做检查，若过期则删除                          | 若某些key由于未被请求，惰性删除便不会被触发，内存占用会越来越高 |

#### [内存淘汰策略](https://stor.51cto.com/art/201904/594773.htm)

> 弥补`定期删除+惰性删除`的不足（某些未被请求的key并不会出发惰性删除导致的内存占用越来越高）
>
> 内存超限（服务配置中的 ==maxmemory==）时触发 redis 淘汰策略来删除键
>
> 淘汰机制从性能和可靠性做平衡，实际中还需要主动删除没有价值的数据，以此提升Redis整体性能和空间。
>
> 支持 6 种策略

| 类型                             | 内存不足无法纳新时策略                            | 不足                   | 使用程度volatile-lru |
| -------------------------------- | ------------------------------------------------- | ---------------------- | -------------------- |
| volatile-lru                     | 在设置了过期时间的键空间中，移除最近最少使用的key |                        |                      |
| volatile-ttl                     |                                                   |                        |                      |
| allkeys-lru                      | 移除最近最少使用的key                             |                        | 常用                 |
| LFU淘汰（Least Frequently Used） | 不区分是否携带过期时间,淘汰最不常用的key          | 不区分是否携带过期时间 |                      |
| volatile-random                  | 在已设置过期时间的键空间中，随机移除某个key       |                        |                      |
| allkeys-random                   |                                                   |                        |                      |
| noeviction                       | 内存不足无法写入时，新写入操作会报错              |                        |                      |



#### 持久化机制

> 数据同步到硬盘文件来保证数据持久化，重启后通过重新加载硬盘文件到内存，达到恢复数据的目的。

| 类型 | 特点                                                         | 优点                                               | 不足                                                         |
| ---- | ------------------------------------------------------------ | -------------------------------------------------- | ------------------------------------------------------------ |
| RDB  | 1 Redis默认的持久化方式。<br />按照一定的时间周期策略把内存的数据以快照的形式保存到硬盘的二进制文件。<br />2 即Snapshot快照存储，对应产生的数据文件为dump.rdb，通过配置文件中的save参数来定义快照的周期。<br />3 通过fork子进程实现<br />4 配置为： save 900 1（在900秒(15分钟)之后，如果至少有1个key发生变化，则dump内存快照。） | 相比于AOF机制，如果数据集很大，RDB的启动效率会更高 | 1 系统一旦在定时持久化之前宕机，未来得及写入磁盘的数据都将丢失<br />2 数据集过大时会卡顿 |
| AOF  | 1 Redis会将每一个收到的写命令都通过Write函数追加到文件最后，类似于MySQL的binlog。当Redis重启是会通过重新执行文件中保存的写命令来在内存中重建整个数据库的内容<br />2 通过 appendfsync [always\|no\|everysec] 参数设置 | 数据安全性较大                                     |                                                              |



#### Redis 集群

> 



| 集群模式          | 特点                                                         | 优缺点 |
| ----------------- | ------------------------------------------------------------ | ------ |
| 主从复制          |                                                              |        |
| 哨兵机制 Sentinel | 解决主从节点高可用的问题。监控主从服务器运行状态；检测到 master 宕机时，会发布消息进行选举，自动将 slave 提升为 master |        |
| Cluster 模式      | 分布式解决方案，解决单点故障与扩展性的问题。如在单个 redis 发生故障或内存不足时，使用 Cluster 进行分片存储 |        |

#### Redis 哈希槽

- Redis 集群没有使用一致性 hash，而是引入了哈希槽的概念。

- Redis 集群有 16384 个哈希槽，每个 key 通过 CRC16 算法计算的结果，对 16384 取模后放到对应的编号在 0-16383 之间的哈希槽，集群的每个节点负责一部分哈希槽

#### Redis如何实现消息延迟

#### 如何保证存的都是热点数据

#### Redis的队列如何异步使用？

#### 最佳实践

#### 常见问题

##### 1 处理过大量的key同一时间过期吗？需要注意什么

**问题**：大量的 key 集中在某个时间点过期，Redis 可能会出现短暂的卡顿现象。如果访问量大的情况下，还可能出现缓存雪崩

**方案**： 可以在时间上加一个随机值，分散过期时间点



### *2.2 MongoDb* (非必须)

# 第四章 分布式系统

## 1 并发基础

### [1.1 线程状态](http://112.126.97.51:82/wp-content/uploads/2020/02/线程状态.png)

### 1.2 生命周期

### 1.3 运行及执行原理

### 1.4 线程池运行原理

### 1.5 并行与并发

## 2 锁机制

### 2.1 volatile

### 2.2 synchronized 

### 2.3 CAS

### 2.4 ABA

## 3 常见问题

### session 一致性

### 一致性 Hash 问题

### 生成全局 ID

### 分布式事务

## 4 系统理论

### BASE 理论

### CAP理论

### Paxos 算法

## 5 网络及通信基础

### Netty

### 序列化

## 6 服务治理

### 服务限流

### 服务熔断

### 服务降级

---

# 第五章 项目实战

## 1 架构演变

>  单一应用架构 -> 垂直应用架构 -> 分布式服务架构 -> 流动计算架构

![服务架构演进](http://112.126.97.51:82/wp-content/uploads/2020/02/架构演变.jpg)



## 2  微服务

### 2.1 微服务基础

#### Spring Boot

- 说说你的理解
- 自动装配的原理

#### Spring Cloud

#### Spring Boot + Dubbo + Nexus

## 3 缓存

- 缓存的合理性
- 缓存崩溃、缓存降级、缓存穿透、缓存预热、缓存更新、缓存降级



## 4 消息队列

### 基本原理及常用模型

- 消息重发补偿、幂等性及消息堆积的解决思路
- 如何保证消息的有序性



### 5 常用中间件

#### RabbitMq

#### Kafka

- 基本原理

#### Zookeeper

- 基本原理
- 选举算法
- 假死脑裂：

> 该问题就是服务集群因为网络震荡导致的多主多从问题，解决方案就是设置服务切换的超时时间，但也同时会导致无法达到高可用的要求





## 5 [设计模式](http://c.biancheng.net/design_pattern/)

> 设计模式最早应用与建筑领域的设计中。
>
> 懂了设计模式就懂了面向对象的分析方法和设计（OOA/D）的精要。

### 接口设计七大原则

### 单一职责

> 一个类应该有且仅有一个引起它变化的原因，否则类应该被拆分（There should never be more than one reason for a class to change）

### 接口隔离

### 依赖倒转（DIP）

> 要面向接口编程，不要面向实现编程，以此来降低类间的耦合性

### 里氏替换

> 继承必须确保超类所拥有的性质在子类中仍然成立

### 开闭原则

> 软件实体应当对扩展开放，对修改关闭

### 迪米特法则

> 其目的是降低类之间的耦合度，提高模块的相对独立性。

### 合成复用（CRP）

> 软件复用时，要尽量先使用组合或者聚合等关联关系来实现，其次才考虑使用继承关系来实现
>
> 如果要使用继承关系，则必须严格遵循里氏替换原则







# 第六章 大数据

## 1 hadoop

### HDFS

### YARN

### HBASE

## 2 spark

